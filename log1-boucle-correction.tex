\chapter*{Correction des exercices 7.4}

\vspace{-2cm}

\begin{Emphase}{Exercice 3 -- Afficher les $n$ premiers}
\begin{pseudoN}

\Module{strictementPositifs}{}{}

    \Decl n, i~:~entiers
    \Read n

    \For{i \From 1 \To n}
        \Write i
    \EndFor

\EndModule
\\
\Module{strictementPositifsDécroissants}{}{}

    \Decl n, i~:~entiers
    \Read n

    \For{i \From n \To 1 \By -1}
        \Write i
    \EndFor

\EndModule
\\ 
\Module{carrésParfaits}{}{}

    \Decl n, i~:~entiers
    \Read n

    \For{i \From 1 \To n}
        \Write i$^2$
    \EndFor

\EndModule
\\
\Module{naturelsImpairs}{}{}

    \Decl n, nb, i~:~entiers
    \Read n

    \Let nb \Gets 1

    \For{i \From 1 \To n}
        \Write nb
        \Let nb \Gets nb + 2
    \EndFor

\EndModule
\\
\Module{naturelsImpairsInférieurs}{}{}

    \Decl n, i~:~entiers
    \Read n

    \For{i \From 1 \To n \By 2}
        \Write i
    \EndFor

\EndModule

\end{pseudo}
\end{Emphase}

\newpage

\begin{Emphase}{Exercice 4 -- Maximum de cotes}
\begin{pseudoN}
\Module{maxCote}{}{}

    \Decl cote, max~:~entier
    \Let cote \Gets 0
    \Let max \Gets 0
    \Read cote
    \While{cote $\ge$ 0}
        \If{cote > max}
            \Let max \Gets cote
        \EndIf
        \Read cote
    \EndWhile
    \Write max

\EndModule
\end{pseudo}
\end{Emphase}


\begin{Emphase}{Exercice 5 -- Afficher les multiples de 3}
\begin{pseudoN}
\Module{multiplesDe3}{}{}

    \Decl nombre, multiple3~:~entiers
    \Let nombre \Gets 1
    \Read nombre
    \While{nombre $\ne$ 0}
        \If{nombre MOD 3 = 0}
           \Write nombre
           \Let multiple3 \Gets multiple3 + 1
        \EndIf
        \Read nombre
    \EndWhile
    \Write multiple3

\EndModule
\end{pseudo}
\end{Emphase}



\begin{Emphase}{Exercice 6 -- Placement d’un capital}
\begin{pseudoN}
\Module{placementCapital}{}{}

    \Decl capitalDépart, nbAnnées, tauxPlacement, capitalIntérêt~:~entiers
    \Read capitalDépart, nbAnnées, tauxPlacement
    \For{année \From 2013 \To n}
        \Let capitalIntérêt \Gets capitalDépart + (tauxPlacement *
        capitalDépart)/100
        \Write année, capitalDépart, capitalIntérêt - capitalDépart
    \EndFor

\EndModule
\end{pseudo}
\end{Emphase}

\newpage

\begin{Emphase}{Exercice 7 -- Produit de 2 nombres}
\begin{pseudoN}
\Module{min}{nb1, nb2~:~entiers}{entier}
    
    \If{nb1 < nb2}
        \Return nb1
    \Else
        \Return nb2
    \EndIf

\EndModule

\Module{produit2Nb}{nb1, nb2~:~entiers}{entier}

    \Decl max, min, somme~:~entiers
    \Let somme \Gets 0
    \Let max \Gets max(nb1, nb2)
    \Let min \Gets min(nb1, nb2)

    \For{i \From 1 \To abs(min)}
        \Let somme \Gets somme + max
    \EndFor

    \If{min < 0}
        \Let somme \Gets -somme
    \EndIf

    \Return somme

\EndModule
\end{pseudo}
\end{Emphase}

\vspace{-0.35cm}

\begin{Emphase}{Exercice 8 -- Génération de suites (1/2)}
\begin{pseudoN}

\Module{pasCroissant}{n~:~entier}{}

    \Decl nb~:~entier
    \Let nb \Gets 1

    \For{i \From 1 \To n}
        \Write nb
        \Let nb \Gets nb + i
    \EndFor

\EndModule
\\

\Module{boiteuse}{n~:~entier}{}

    \Decl nb, pas~:~entiers
    \Let nb \Gets 1
    \Let pas \Gets 2

    \For{i \From 1 \To n}

        \Write nb

        \Let pas \Gets 3 - pas

        \Let nb \Gets nb + pas

    \EndFor

\EndModule
\\

\Module{suiteDeFibonacci}{n~:~entier}{}

    \Decl val, prec~:~entiers
    \Let val \Gets 0
    \Let prec \Gets 1

    \For{i \From 1 \To n}
        \Write val
        \Let val \Gets val + prec
        \Let prec \Gets val - prec
    \EndFor

\EndModule

\end{pseudo}
\end{Emphase}

\newpage

\begin{Emphase}{Exercice 8 -- Génération de suites (2/2)}
\begin{pseudoN}


\Module{processionEchternach}{n~:~entier}{}

    \Decl val, i~:~entier
    \Let val \Gets 1
    \For{i \From 1 \To  n}
        \Write val

        \If{1 $\le$ i MOD 5 ET i MOD 5 $\le$ 3}
            \Let val \Gets val + 1
        \Else
            \Let val \Gets val - 1
        \EndIf

    \EndFor

\EndModule
\\

\Module{combinaison2Suites}{n~:~entier}{}

    \Decl première~:~booléen
    \Decl val1, val2~:~entiers

    \Let première \Gets vrai
    \Let val1 \Gets 1
    \Let val2 \Gets 2

    \For{i \From 1 \To n}
        \If{première}
            \Write val1
            \Let val1 \Gets val1 + 2
        \Else
            \Write val2
            \Let val2 \Gets val2 + 1
        \EndIf
        \Let première \Gets NON première
    \EndFor

\EndModule
\\
\Module{capricieuse}{n~:~entier}{}

    \Decl val, pas~:~entiers
    \Decl descendant~:~booléen

    \Let val, pas \Gets 1
    \Let descendant \Gets faux

    \For{i \From 1 \To n}
        \Write val

        \If{pas = 10}
            \Let val \Gets val + 10
            \Let descendant \Gets NON descendant
            \Let pas \Gets 0
        \Else

            \If{descendant}
                \Let val \Gets val - 1
            \Else
                \Let val \Gets val + 1
            \EndIf

        \EndIf

        \Let pas \Gets pas + 1

    \EndFor


\EndModule

\end{pseudo}
\end{Emphase}

\newpage

\begin{Emphase}{Exercice 9 -- Factorielle}
\begin{pseudoN}
\Module{factorielle}{n~:~entier}{entier}

    \If{n > 1}
        \Return n * factorielle(n - 1)
    \Else
        \Return 1
    \EndIf

\EndModule

\end{pseudo}
\end{Emphase}

\begin{Emphase}{Exercice 10 -- Somme de chiffres}
\begin{pseudoN}
\Module{sommeChiffre}{}{}

    \Decl chiffre, nombre~:~entiers
    \Let chiffre \Gets 0
    \Read nombre

    \While{nombre > 0}
        \Let chiffre \Gets chiffre + nombre MOD 10
        \Let nombre \Gets nombre / 10 
    \EndWhile

    \Write chiffre

\EndModule

\end{pseudo}
\end{Emphase}

\begin{Emphase}{Exercice 11 -- Conversion binaire-décimal}
\begin{pseudoN}
\Module{BinaireDécimal}{}{}

    \Decl décimal, i~:~réels
    \Decl nb~:~entier
    \Let décimal \Gets 0
    \Let i \Gets 0
    \Read nb

    \While{nb > 0}
        \Let décimal \Gets nb MOD 10 * 2$^i$ + décimal
        \Let nb \Gets nb / 10 
        \Let i \Gets i + 1
    \EndWhile

    \Return décimal

\EndModule

\end{pseudo}
\end{Emphase}

\newpage

\begin{Emphase}{Exercice 12 -- Conversion décimal-binaire}
\begin{pseudoN}
\Module{DécimalBinaire}{}{}

    \Decl binaire~:~chaine
    \Decl nb~:~entier
    \Read nb

    \While{nb > 0}
    \Let binaire \Gets concat(binaire, nb MOD 2)
        \Let nb \Gets nb / 2 
    \EndWhile

    \For{i \From long(binaire) \To 1 \By -1}
        \Write car(binaire, i)
    \EndFor

    \Write binaire

\EndModule

\end{pseudo}
\end{Emphase}

\begin{Emphase}{Exercice 13 -- PGCD}
\begin{pseudoN}

\Module{PGCD}{a, b~:~entiers}{entier}

    \Decl reste~:~entier

    \While{reste != 0}
    \Let reste \Gets a MOD b

    \Let a \Gets b
    \Let b \Gets reste
    \EndWhile

    \Return a

\EndModule

\end{pseudo}
\end{Emphase}

\begin{Emphase}{Exercice 14 -- PPCM}
\begin{pseudoN}

\Module{PPCM}{a, b~:~entiers}{entier}

    \Return abs(a * b) / PGCD(a, b)

\EndModule

\end{pseudo}
\end{Emphase}

\newpage

\begin{Emphase}{Exercice 15 -- Nombre premier}
\begin{pseudoN}

\Module{estPremier}{nb~:~entier}{booléen}

    \If{nb = 0 OU nb = 1}

        \Return faux

    \EndIf

    \If{nb = 2}

        \Return vrai

    \EndIf

    \If{nb MOD 2 = 0}
        
        \Return faux

    \EndIf

    \For{i \From 3 \To $\sqrt{\text{nb}}$ \By 2}

        \If{nb MOD i = 0}
            
            \Return faux

        \EndIf

    \EndFor

    \Return vrai

\EndModule

\end{pseudo}
\end{Emphase}


\begin{Emphase}{Exercice 16 -- Nombres premiers}
\begin{pseudoN}

\Module{nombresPremiers}{nb~:~entier}{}

    \For{i \From 1 \To nb \By 2}
        \If{estPremier(i)}
            \Write i
        \EndIf
    \EndFor

  \EndModule

\end{pseudo}
\end{Emphase}


\begin{Emphase}{Exercice 17 -- Nombre parfait}
\begin{pseudoN}

\Module{nbParfait}{nb~:~entier}{booléen}

\Decl p~:~entier

\If{nb = 6}
    \Return vrai
\EndIf

\Let p \Gets 3
\While{nb < $2^{(p - 1)} (2^p - 1)$}
    \Let p \Gets p + 2
\EndWhile

\Return n = $2^{(p - 1)} (2^p - 1)$

\EndModule

\end{pseudo}
\end{Emphase}

\newpage

\begin{Emphase}{Exercice 18 -- Décomposition en facteurs premiers}
\begin{pseudoN}

\Module{facteursPremiers}{nb~:~entier}{}

    \Decl i~:~entier
    \Let i \Gets 2
    \While{i <= nb}
        \While{nb MOD i = 0 ET estPremier(i)}
            \Write i
            \Let nb \Gets nb/i
            \If{nb >= 1}
                \Write " * "
            \EndIf
        \EndWhile
        \Let i \Gets i + 1
    \EndWhile

\EndModule

\end{pseudo}
\end{Emphase}


\begin{Emphase}{Exercice 19 -- Palindrome}
\begin{pseudoN}

\Module{palindrome}{nb~:~entier}{booléen}

    \Decl palindrome, inverse~:~entiers
    \Let inverse \Gets 0
    \Let palindrome \Gets nb
    \While{palindrome != 0}

        \Let chiffre \Gets palindrome MOD 10
        \Let inverse \Gets inverse * 10 + chiffre
        \Let palindrome \Gets palindrome / 10

    \EndWhile

    \Return nb = inverse

\EndModule

\end{pseudo}
\end{Emphase}

\newpage

\begin{Emphase}{Exercice 20 -- Jeu de la fourchette}
\begin{pseudoN}

\Module{fourchette}{}{}

    \Decl nbRandom, essai, tentative~:~entiers
    \Let tentative \Gets 0
    \Let nbRandom \Gets hasard(100)

    \Repeat

        \Write "Entrez un nombre"
        \Read essai

        \Switch
    \Case{nbRandom > essai} \Write "le nb est plus grand"
    \Case{nbRandom < essai} \Write "le nb est plus petit"
        \EndSwitch

        \Let tentative \Gets tentative + 1

    \Until{tentative $\ne$ 8 OU nbRandom $\ne$ essai}

    \If{nbRandom $\ne$ essai}
        \Write "désolé, le nb était ", nbRandom
    \Else
        \Write "bravo, vous avez trouvé en ", tentative, " coups"
    \EndIf

\EndModule

\end{pseudo}
\end{Emphase}

\begin{Emphase}{Exercice 21 -- IMC}
\begin{pseudoN}

\Module{IMC}{}{}

    \Decl imc~:~réel
    \Decl sexe, poids, taille~:~réels
    \Decl obèse, nbPersonnes~:~entier
    \Repeat

        \Read sexe, poids, taille
        \Let imc \Gets poids / taille$^2$

        \If{imc > 30}
            \Let obèse \Gets obèse + 1
        \EndIf

        \Let nbPersonnes \Gets nbPersonnes + 1

    \Until{sexe $\ne$ 'H' ET sexe $\ne$ 'F'}

    \Write obèse / nbPersonnes * 100

\EndModule

\end{pseudo}
\end{Emphase}

\newpage

\begin{Emphase}{Exercice 22 -- Cotes}
\begin{pseudoN}

\Module{cotesEtudiants}{}{}

    \Decl coteInt, coteExam, coteTotal, coteMax~:~réel
    \Decl absence, réussite, nbCote~:~entier
    \Decl fin~:~booléen
    \Decl réponse~:~chaine
    \While{fin = faux}

        \For{i \From 1 \To 3}

            \Read cote

            \If{cote = -1}
                \Let cote \Gets absence
            \Else
                \Let coteInt \Gets coteInt + cote
                \Let nbCote \Gets nbCote + 1
            \EndIf

        \EndFor

        \Read coteExam
        \Let nbCote \Gets nbCote + 1
        \If{coteExam = -1}
            \Let coteExam \Gets 0
        \EndIf

        \SwitchC{absence}
            \Case{1}
                \Let coteExam \Gets coteExam / 100 * 120
            \Case{2}
                \Let coteExam \Gets coteExam / 100 * 140
            \Case{3}
                \Let coteExam \Gets coteExam / 100 * 160
        \EndSwitch

        \Let coteTotal \Gets (coteInt + coteExam) / 8

        \If{coteTotal > 12}
            \Let réussite \Gets réussite + 1
        \EndIf

        \Let coteMax \Gets max2Nb(coteMax, coteTotal)

        \Write "Y a-t-il encore des cotes à rentrer ?"
        \Read réponse
        \Let fin \Gets réponse = "non"

    \EndWhile

    \Write nbCote, coteMax, réussite / nbCote * 100

\EndModule

\end{pseudo}
\end{Emphase}


\begin{Emphase}{Exercice 23 -- Normaliser une chaine}
\begin{pseudoN}

\Module{versAlpha}{chaine~:~chaine}{chaine}

    \Decl chaineAlpha~:~chaine
    \Decl lettre~:~caractère
    \For{lettre \From 1 \To long(chaine)}
        \Let lettre \Gets majuscule(car(chaineAlpha, lettre))
        \If{estLettre(lettre)}
            \Let chaineAlpha \Gets concat(chaineAlpha, lettre)
        \EndIf
   \EndFor

    \Return chaineAlpha

\EndModule

\end{pseudo}
\end{Emphase}

\newpage

\begin{Emphase}{Exercice 24 -- Le chiffre de César (1/2)}
\begin{pseudoN}

\Module{chiffrementCésar}{msgClair~:~chaine, k~:~entier}{chaine}

    \Decl msgChiffré~:~chaine
    \Decl carClair, carChiffré~:~caractères
    \Let msgChiffré \Gets ""
    \For{i \From 1 \To long(msgClair)}
        \Let carClair \Gets numLettre(car(msgClair, carClair)) + k
        \If{carClair > 26}
            \Let carClair \Gets carClair MOD 26
        \EndIf
        \If{carClair < 1}
            \Let carClair \Gets abs(carClair - 1) MOD 26 + 1
        \EndIf
        \Let carChiffré \Gets lettre(carClair)
        \Let msgChiffré \Gets concat(msgChiffré, carChiffré)
   \EndFor

    \Return msgChiffré

\EndModule

\end{pseudo}
\end{Emphase}


\begin{Emphase}{Exercice 24 -- Le chiffre de César (2/2)}
\begin{pseudoN}

\Module{déchiffrementCésar}{message~:~chaine, k~:~entier}{chaine}

    \Return chiffrementCésar(message, -k)

\EndModule

\end{pseudo}
\end{Emphase}


\begin{Emphase}{Exercice 24 -- Le chiffre de César (solution Github)}
\begin{pseudoN}
    \Module{chiffrerCésar}{msgClair\In: chaine, déplacement\In: entier}{chaine}
        \Decl msgChiffré : chaine
        \Decl carClair, carChiffré : caractères
        \Decl i : entier
        \Empty
        \Let msgChiffré \Gets ""
        \For{i \K{de} 1 \K{à} long(msgClair)}
             \Let carClair \Gets car(msgClair,i)
             \Let carChiffré \Gets avancer(carClair, déplacement)
             \Let msgChiffré \Gets concat( msgChiffré, chaine(carChiffré) )
        \EndFor
        \Return msgChiffré
        \EndModule

			\Empty
        \LComment{Calcule la lettre qui est "delta" position plus loin dans l'alphabet (circulairement)}
        \Module{avancer}{lettre\In: caractère, delta\In: entier}{caractère}
            \Return lettre( (numLettre(lettre) + delta - 1) MOD 26 + 1 ) 
        \EndModule

			\Empty
        \LComment{Déchiffrer un message chiffré avec le chiffre de César}
        \Module{déchiffrerCésar}{msgClair\In: chaine, déplacement\In: entier}{chaine}
            \Return chiffrerCésar(msgClair, 26 - déplacement)
        \EndModule
\end{pseudo}
\end{Emphase}

