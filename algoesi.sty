% Adaptation du package algorithmicx pour écrire les algorithmes
% du cours de logique à l'ESI

\usepackage{algpseudocode}		% Perme d'écrire des algorithmes
\usepackage{algorithm}			% Pour des algorithmes flottants

% ==============================================================================
% Le code suivant permet d'avoir des lignes verticales pour délimiter les blocs. 
% cf: http://tex.stackexchange.com/questions/52473/is-it-possible-to-have-connecting-loop-lines-like-algorithm2e-in-algorithmic
% J'ai changé la ligne (plus grosse et grise)
% ==============================================================================
\makeatletter
% This is the vertical rule that is inserted
\definecolor{rulecolor}{gray}{0.7}
\def\therule{\makebox[\algorithmicindent][l]{\hspace*{.4em}{\color{rulecolor}\vrule height .75\baselineskip width 0.05em depth .25\baselineskip}}}%

\newtoks\therules% Contains rules
\therules={}% Start with empty token list
\def\appendto#1#2{\expandafter#1\expandafter{\the#1#2}}% Append to token list
\def\gobblefirst#1{% Remove (first) from token list
  #1\expandafter\expandafter\expandafter{\expandafter\@gobble\the#1}}%
\def\LState{\State\unskip\the\therules}% New line-state
\def\pushindent{\appendto\therules\therule}%
\def\popindent{\gobblefirst\therules}%
\def\printindent{\unskip\the\therules}%
\def\printandpush{\printindent\pushindent}%
\def\popandprint{\popindent\printindent}%

%      ***      DECLARED LOOPS      ***
% (from algpseudocode.sty)
\algdef{SE}[WHILE]{While}{EndWhile}[1]
  {\printandpush\algorithmicwhile\ #1\ \algorithmicdo}
  {\popandprint\algorithmicend\ \algorithmicwhile}%
\algdef{SE}[FOR]{For}{EndFor}[1]
  {\printandpush\algorithmicfor\ #1\ \algorithmicdo}
  {\popandprint\algorithmicend\ \algorithmicfor}%
\algdef{S}[FOR]{ForAll}[1]
  {\printindent\algorithmicforall\ #1\ \algorithmicdo}%
\algdef{SE}[LOOP]{Loop}{EndLoop}
  {\printandpush\algorithmicloop}
  {\popandprint\algorithmicend\ \algorithmicloop}%
\algdef{SE}[REPEAT]{Repeat}{Until}
  {\printandpush\algorithmicrepeat}[1]
  {\popandprint\algorithmicuntil\ #1}%
\algdef{SE}[IF]{If}{EndIf}[1]
  {\printandpush\algorithmicif\ #1\ \algorithmicthen}
  {\popandprint\algorithmicend\ \algorithmicif}%
\algdef{SE}[BLOCK]{Begin}{End}
  {\printandpush \algorithmicbegin}
  {\popandprint \algorithmicend}%
\algdef{C}[IF]{IF}{ElsIf}[1]
  {\popandprint\pushindent\algorithmicelse\ \algorithmicif\ #1\ \algorithmicthen}%
\algdef{Ce}[ELSE]{IF}{Else}{EndIf}
  {\popandprint\pushindent\algorithmicelse}%
\algdef{SE}[PROCEDURE]{Procedure}{EndProcedure}[2]
   {\printandpush\algorithmicprocedure\ \textproc{#1}\ifthenelse{\equal{#2}{}}{}{(#2)}}%
   {\popandprint\algorithmicend\ \algorithmicprocedure}%
\algdef{SE}[FUNCTION]{Function}{EndFunction}[2]
   {\printandpush\algorithmicfunction\ \textproc{#1}\ifthenelse{\equal{#2}{}}{}{(#2)}}%
   {\popandprint\algorithmicend\ \algorithmicfunction}%
\makeatother
% ==============================================================================
% Fin du code pour les lignes verticales
% ==============================================================================

% Ajouts propres pour la francisation des termes prédéfinis
\algnewcommand\algorithmicbegin{\textbf{début}}
\algrenewcommand\algorithmicend{\textbf{fin}}
\algrenewcommand\algorithmicprocedure{\textbf{module}}
\algrenewcommand\algorithmicfunction{\textbf{module}}
\algrenewcommand\algorithmicwhile{\textbf{tant que}}
\algrenewcommand\algorithmicdo{\textbf{faire}}
\algrenewcommand\algorithmicreturn{\textbf{retourner}}
\algrenewcommand\algorithmicif{\textbf{si}}
\algrenewcommand\algorithmicthen{\textbf{alors}}
\algrenewcommand\algorithmicelse{\textbf{sinon}}
\floatname{algorithm}{Algorithme}

% Modifications de style
\algrenewcommand\textproc{\textit} % Nom de module en italique plutôt qu'en small caps
\restylefloat{ labelsep=b }

% ajout d'e petits éléments de syntaxe non existants
\newcommand{\In}{\ensuremath{\downarrow}}
\newcommand{\Out}{\ensuremath{\uparrow}}
\newcommand{\InOut}{\In{}\Out{}}
%\newcommand{\Gets}{\ensuremath{\gets}{}}
\newcommand{\Gives}{\ \ensuremath{\rightarrow}{}}
\newcommand{\T}[1]{\textsf{#1}}

\definecolor{declarecolor}{gray}{0.2}
\renewcommand{\Return}[1]{\LState\algorithmicreturn\ #1}
\newcommand{\Declare}[2]{\LState{#1 : #2}}
\newcommand{\Gets}[2]{\LState #1 \ensuremath{\gets}{} #2}
\newcommand{\Read}[1]{\LState\textbf{lire}\ #1}
\newcommand{\Write}[1]{\LState\textbf{écrire}\ #1}
\newcommand{\Empty}{\LState}
\newcommand{\Stmt}{\LState}
\newcommand{\K}[1]{\textbf{#1}}

% \Module{nom}{param}{return_type} ... \EndModule
\algblockdefx[MODULE]{Module}{EndModule}
[3]{\printandpush\algorithmicprocedure\ \textproc{#1}(#2)\ifthenelse{\equal{#3}{}}{}{\Gives\ #3}}
{\algorithmicend\ \algorithmicprocedure}

% =====
\newenvironment{algoesi}{%
  \begin{sffamily}
  \begin{algorithmic}[0]
}{%
  \end{algorithmic}
  \end{sffamily}
}

\newenvironment{pseudo}[1]{%
\begin{algorithm}
  \caption{#1}
  \begin{algoesi}
}{%
  \end{algoesi}%
  \end{algorithm}%
}




